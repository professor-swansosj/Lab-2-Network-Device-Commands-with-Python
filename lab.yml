# ==========================================
# Course: Software Defined Networking
# Module: Network Device Commands with Python
# Purpose: Hands on activity for interacting with network devices using Netmiko and ntc-templates
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: Lab 2 — Network Device Commands with Python
course: Software Defined Networking
module: Network Automation Fundamentals
lab_number: 2
time_estimate: 90-120 Minutes


#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "Installing Python Libraries with pip"
    content: > 
      Terms in Python can sometimes be up to the individual communicating. Python comes with standard 
      built-in libraries such as `os`, `sys`, `math`, `datetime`, and `json`. However there are many 
      community developed that can easily be downloaded, imported, and used to help us write cleaner 
      code. Netmiko for example include paramiko so when you download netmiko it additionally has a 
      dependency on paramiko therefore paramiko is also installed when we install netmiko. There a few 
      methods to install a python library with the most common being the `pip` command line utility. which
      stands for 'Python Installer Package'.

      You can find more information about pip here: https://pip.pypa.io/en/stable/ or by running `pip --help`.
      In the example below we use pip to install the netmiko library which is a multi-vendor library that simplifies
      and standardizes the process of connecting to network devices via SSH.

    code_block:
      language: bash
      code: |
        pip install netmiko

  - title: "Maintain the `requirements.txt` File"
    content: > 
      When working on a project it is common to have multiple dependencies. To make it easier to manage
      these dependencies we can use a `requirements.txt` file. This file is simply a text file that lists
      the libraries and their versions that are required for the project. This makes it easy for others to
      install the same dependencies by simply running a single command.

      You can create a `requirements.txt` file manually or you can generate one using the `pip freeze` command.
      The `pip freeze` command lists all the installed packages in the current environment along with their versions.
      You can redirect this output to a `requirements.txt` file using the following command:

    code_block:
      language: bash
      code: |
        pip freeze > requirements.txt

    code_notes: >
      This will create a `requirements.txt` file in the current directory with a list of all the installed packages
      and their versions. You can then share this file with others or use it to recreate the same environment later.

  - title: "Install Dependencies from `requirements.txt`"
    content: > 
      To install the dependencies listed in a `requirements.txt` file, you can use the following command:

    code_block:
      language: bash
      code: |
        pip install -r requirements.txt

    code_notes: >
      This will read the `requirements.txt` file and install all the packages listed in it.

  - title: "Using Virtual Environments"
    content: > 
      When working on multiple Python projects, it is common to have different dependencies and versions
      of libraries for each project. To avoid conflicts between these dependencies, it is recommended to
      use virtual environments. A virtual environment is a self-contained directory that contains its own
      Python interpreter and libraries.

      You can create a virtual environment using the `venv` module that comes with Python. To create a virtual
      environment, you can use the following command:

    code_block:
      language: bash
      code: |
        python -m venv myenv
        source myenv/bin/activate
        pip install -r requirements.txt

    code_notes: >
      This will create a virtual environment named `myenv` in the current directory and activate it.
      Once the virtual environment is activated, any packages you install using `pip` will be installed
      in the virtual environment instead of the global Python environment which is responsible for some of your
      system operations. You can then install the dependencies listed in the `requirements.txt` file without affecting
      other projects or system operations.

  - title: "Cleanup a Virtual Environment"
    content: > 
      To deactivate a virtual environment and return to the global Python environment, you can use the deactivate command. 
      This will restore your PATH and other environment variables to their original state. You can then delete the virtual 
      environment directory if you no longer need it. If you need it back again you can always recreate it.

    code_block:
      language: bash
      code: |
        deactivate

        rm -rf myvenv

  - title: "Using the dir(), help(), and inspect Modules"
    content: >
      When working with Python libraries, it is often helpful to explore the available classes, methods, and functions.
      The `dir()` function can be used to list the attributes of a module or class. The `help()` function can be used
      to display the documentation for a module, class, or function. The `inspect` module provides several useful functions
      to get information about live objects such as modules, classes, methods, functions, tracebacks, frame objects, and code objects.

      You can use these functions to explore the Netmiko library and identify the correct device type and method to send commands to the device.

    code_block:
      language: python
      code: |
        import netmiko
        help(netmiko)
        dir(netmiko)

        inspect.getmembers(netmiko)

    code_notes: >
      This will display the documentation and attributes of the Netmiko library, allowing you to identify
      the correct device type and method to use for your project.

  - title: "Getting Credentials Securely"
    content: >
      When working with network devices, it is important to handle credentials securely. Hardcoding
      credentials in your scripts can lead to security vulnerabilities if the code is shared or stored
      in a public repository. Instead, you can use the `input()` function to prompt for the username and
      the `getpass` module to securely prompt for the password without echoing it to the terminal.

    code_block:
      language: python
      code: |
        import getpass

        username = input("Enter your username: ")
        password = getpass.getpass("Enter your password: ")

    code_notes: >
      This will prompt the user to enter their username and password at runtime, ensuring that the
      credentials are not stored in the code or visible in the terminal.

  - title: "Device Setup for Netmiko"
    content: >
      To connect to a network device using Netmiko, you need to create a device dictionary that contains
      the necessary connection parameters. The device dictionary should include the device type, host (IP address
      or hostname), username, and password. You can also include optional parameters such as port, secret, and
      timeout.

    code_block:
      language: python
      code: |
        device = {
          "device_type": "cisco_ios",
          "host": "sandbox-iosxe-latest-1.cisco.com",
          "username": username,
          "password": password,
          "port": 22,
          "secret": password,
          "timeout": 10
        }

    code_notes: >
      This device dictionary can then be passed to the Netmiko connection class to establish a connection
      to the device.

  - title: "ConnectHandler"
    content: >
      The `ConnectHandler` class in Netmiko is used to establish an SSH connection to a network device.
      You can create an instance of the `ConnectHandler` class by passing the device dictionary as an argument.
      Once the connection is established, you can use various methods to send commands to the device and retrieve
      the output.

    code_block:
      language: python
      code: |
        from netmiko import ConnectHandler

        net_connect = ConnectHandler(**device)
        output = net_connect.send_command("show ip interface brief")
        print(output)

    code_notes: >
      This code imports the `ConnectHandler` class from the Netmiko library, creates an instance of the class
      using the device dictionary, and sends a command to the device. The output of the command is then printed
      to the console.

  - title: "Sending Commands"
    content: >
      The `send_command()` method of the `ConnectHandler` class is used to send a single command to the network device
      and retrieve the output. You can pass the command as a string argument to the method. The method returns the
      output of the command as a string.

    code_block:
      language: python
      code: |
        from netmiko import ConnectHandler

        net_connect = ConnectHandler(**device)
        output = net_connect.send_command("show ip interface brief")
        print(output)

    code_notes: >
      This code imports the `ConnectHandler` class from the Netmiko library, creates an instance of the class
      using the device dictionary, and sends a command to the device. The output of the command is then printed
      to the console.

  - title: "TextFSM and ntc-templates"
    content: >
      TextFSM is a Python library that allows you to parse unstructured text into structured data using templates.
      The ntc-templates project provides a collection of pre-defined TextFSM templates for various network devices
      and commands. You can use these templates to parse the output of commands sent to network devices using Netmiko.

      To use ntc-templates, you need to install the library and set the `NET_TEXTFSM` environment variable to point
      to the directory containing the templates. You can then use the `parse_output()` function from the `ntc_templates.parse` module
      to parse the command output using the appropriate template.

    code_block:
      language: python
      code: |
        from ntc_templates.parse import parse_output

        template = "cisco_ios_show_ip_interface_brief.textfsm"
        parsed_output = parse_output(template, output)
        print(parsed_output)

    code_notes: >
      This code imports the `parse_output()` function from the `ntc_templates.parse` module, specifies the template to use for parsing,
      and parses the output of the command. The structured data is then printed to the console.

  - title: "f-text Strings"
    content: >
      f-strings, also known as formatted string literals, are a way to embed expressions inside string literals,
      using curly braces `{}`. They were introduced in Python 3.6 and provide a more readable and concise way to format strings.

      To create an f-string, you simply prefix the string with the letter `f` or `F`. Inside the string, you can include
      any valid Python expression within curly braces, and the expression will be evaluated at runtime and inserted into the string.

    code_block:
      language: python
      code: |
        interface = "GigabitEthernet0/1"
        ip_address = "192.168.1.1"
        subnet_mask = "255.255.255.0"

        config = f"""
        interface {interface}
          ip address {ip_address} {subnet_mask}
        """
        print(config)

    code_notes: >
      This code defines variables for an interface name, IP address, and subnet mask, and then uses an f-string to create a multi-line configuration string.
      The variables are embedded within the string using curly braces, and the resulting configuration is printed to the console.

#=====================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#=====================================================

overview: >
  In this lab you’ll connect to a Cisco DevNet Always-On Catalyst device using Netmiko,
  run read-only “show” commands, push a small loopback config, then parse CLI output with
  ntc-templates to produce a short report. The emphasis is on safe automation patterns:
  prompting for credentials, error handling, structured data, and clean logging.

objectives:
  - Use Netmiko to establish an SSH session to a Cisco Catalyst 9K in the Cisco DevNet Always-On Sandbox.
  - Collect credentials securely at runtime using input() and getpass.getpass().
  - Execute basic IOS “show” commands and capture output to files.
  - Implement Python error handling (try/except) for connection and command failures.
  - Push simple configuration (loopback interfaces) from Python using iterable data structures.
  - Parse unstructured CLI output into structured data with ntc-templates (TextFSM).
  - Generate a simple, formatted report using f-strings (or Jinja2, optional).

python_version: "3.11"
accounts: ["GitHub", "Cisco DevNet"]
devices: ["Cisco DevNet Always-On Catalyst (IOS-XE/9K)"]

deliverables:
  readme_summary: "README and INSTRUCTIONS standardized; logs and artifacts present"
  instructions_summary: "Scripts complete; required log markers present; autograder passes"

grading:
  total_points: 75
  rows:
    - { step: "1. Setup",           requirement: "Container opens and packages installed",                    points: 5 }
    - { step: "2. Explore library", requirement: "Show methods or details from Netmiko",                      points: 5 }
    - { step: "3. Secure login",    requirement: "Use input for username and hidden password",                points: 4 }
    - { step: "3. Secure login",    requirement: "Device dictionary has type, host, username, password",      points: 4 }
    - { step: "4. Connect",         requirement: "Successful connection made to device",                      points: 5 }
    - { step: "5. Show command",    requirement: "Run a show command and save raw output to file",            points: 5 }
    - { step: "6. Error handling",  requirement: "Script shows clear error message for bad login or timeout", points: 8 }
    - { step: "7. Loopback config", requirement: "Add loopback from list of dictionaries",                    points: 8 }
    - { step: "7. Loopback config", requirement: "Show command verifies loopbacks and saves to file",         points: 6 }
    - { step: "8. Parse output",    requirement: "Use templates to parse show command into structured data",  points: 7 }
    - { step: "8. Parse output",    requirement: "Print structured data in clear format",                     points: 3 }
    - { step: "9. Report",          requirement: "Create and save formatted report with key device details",  points: 10 }
    - { step: "All steps",          requirement: "Logs created with start and end, no secrets shown",         points: 5 }

tips:
  - title: Dev Container Didn’t Install Dependencies
    symptom: "ModuleNotFoundError for netmiko or ntc_templates when running code."
    fix: "Open in devcontainer; verify with `pip list`. If missing, run `pip install -r requirements.txt`."
  - title: Wrong Hostname or IP Address
    symptom: "Connection times out or immediately fails."
    fix: "Use the exact host/IP from the DevNet page. If hostname fails, try the raw IP; verify DNS with `ping`."
  - title: Incorrect Device Type
    symptom: "Login fails or 'Authentication to device failed'."
    fix: "Confirm exact `device_type` from Netmiko (e.g., `cisco_ios` / `cisco_xe`). Check with `dir(netmiko)`."
  - title: Hard-Coded Credentials
    symptom: "Secrets visible in Git history."
    fix: "Use `input()` and `getpass.getpass()`; rotate credentials if accidentally committed."
  - title: Empty Parsed Data
    symptom: "`parse_output()` returns [] or IndexError."
    fix: "Match the template’s expected command exactly (e.g., `show ip interface brief`)."
  - title: File Writing Errors
    symptom: "FileNotFoundError or empty outputs."
    fix: "Write to the correct relative paths under `data/` and `logs/`."

autograder:
  log_path: logs/lab.log
  required_markers:
    - "LAB2_START"
    - "DEVCONTAINER_OK"
    - "PKG_OK: netmiko"
    - "PKG_OK: ntc-templates"
    - "CONNECT_OK"
    - "CMD=show ip interface brief"
    - "RAW_SAVED"
    - "ERR=AuthenticationException"
    - "ERR=NetMikoTimeoutException"
    - "ERR=SSHException"
    - "CFG_APPLIED"
    - "VERIFY_OK"
    - 'PARSE_OK platform=cisco command="show ip interface brief"'
    - "PPRINT_OK"
    - "REPORT_SAVED"
    - "LAB2_END"


resources:
  - title: Cisco DevNet Always-On Sandboxes
    url: https://developer.cisco.com/site/sandbox/
    note: Find the Catalyst IOS-XE device details here.
  - title: Netmiko Documentation
    url: https://ktbyers.github.io/netmiko/
  - title: NTC Templates (TextFSM)
    url: https://github.com/networktocode/ntc-templates
    note: Match exact command strings to template names.

license: "© 2025 Your Name — Classroom use."

before_you_begin: >
  Confirm the Always-On sandbox is online and note the current hostname/IP, SSH port,
  and default credentials from DevNet. Inside the dev container, verify DNS and outbound
  network access (`ping`, `curl ifconfig.me`).

steps:
  - title: Clone the Repository
    goal: "Getting your own copy of the starter repo."
    actions: |
      Clone the repo and change into the directory so GitHub Classroom can grade your work in-place.
      (See your assignment link for the correct URL.)
    done_when: |
      - You are in the new folder (`pwd` shows the repo path).
      - `git status` shows you’re on the default branch with no local changes.
    log_marker: "LAB2_START"

  - title: Open a Dev Container
    goal: "Open a consistent dev environment (Python libs preinstalled)."
    actions: |
      Reopen in Container and wait for the first-time build to finish. Then review the health files.
    done_when: |
      - `logs/DEVCONTAINER_STATUS.txt` shows `Overall status: READY`.
      - `logs/devcontainer_health.log` shows DNS_OK / NET_OK / PKG_OK lines.
    log_marker: "DEVCONTAINER_OK"

  - title: Confirm Sandbox Target
    goal: "Identify the exact device and verify reachability from the container."
    actions: |
      Note the host/IP, port, username, and password from DevNet. Test name resolution and ping from inside the container.
    done_when: |
      - You can reach the host/IP (ping succeeds or IP reachable).
      - You can SSH interactively (optional sanity check).
    log_marker: "SANDBOX_READY"

  - title: Explore the Library Surface Area
    goal: "Discover the connection class, device types, and send-command method."
    actions: |
      In `python`, use `dir()`, `help()`, and `inspect` to explore Netmiko and identify the correct `device_type`.
    done_when: |
      - You can name the connection class you’ll use.
      - You can state the correct device type string for IOS/IOS-XE.
      - You know which method sends a command to the device.
    log_marker: "STEP_DONE"

  - title: Establish Connection & Run a Show Command
    goal: "Build your first script that connects and runs one command."
    actions: |
      Create `src/connect_basic.py`. Prompt for creds, build the device dict, connect, run `show ip interface brief`,
      print output, and save raw output to `data/raw/show_ip_int_brief.txt`. Log events to `logs/connect_basic.log`.
    done_when: |
      - You see command output in the terminal.
      - `data/raw/show_ip_int_brief.txt` is non-empty.
      - `logs/connect_basic.log` shows CONNECT_OK, CMD=..., RAW_SAVED=...
    log_marker: "CONNECT_OK"

  - title: Add Error Handling
    goal: "Handle bad creds, timeouts, and SSH failures gracefully."
    actions: |
      Create `src/connect_with_errors.py`. Wrap connect/command in try/except; print clear messages; log an exit-with-error line.
    done_when: |
      - A friendly error shows for bad password and for unreachable host.
      - `logs/connect_with_errors.log` shows one of: AuthenticationException / NetMikoTimeoutException / SSHException and EXIT_WITH_ERROR.
    log_marker: "EXIT_WITH_ERROR"

  - title: Automate Loopback Configuration
    goal: "Push small, repeatable config from structured data and verify."
    actions: |
      Create `src/add_loopbacks.py`. Iterate a list of dictionaries to add Loopbacks, verify via show command,
      and save verification to `data/raw/verify_loopbacks.txt`. Log one line per interface.
    done_when: |
      - Loopbacks appear in device output.
      - `data/raw/verify_loopbacks.txt` exists and is non-empty.
      - `logs/add_loopbacks.log` shows CFG_APPLIED lines and a VERIFY_OK line.
    log_marker: "CFG_APPLIED count=<n>"

  - title: Parse CLI Output with ntc-templates
    goal: "Convert raw CLI to structured data with TextFSM templates."
    actions: |
      Create `src/parse_and_report.py`. Run show commands and parse with ntc-templates; pretty-print the structured data.
    done_when: |
      - Terminal shows structured data.
      - `logs/parse_and_report.log` shows PARSE_OK and PPRINT_OK.
    log_marker: "PARSE_OK command=\"show ip interface brief\""

  - title: Generate a Short Report
    goal: "Produce a readable summary file."
    actions: |
      In the same script, build a brief report (hostname, model, uptime, up/up count) and save to `data/reports/device_report.txt`.
    done_when: |
      - `data/reports/device_report.txt` exists with the key fields.
      - `logs/parse_and_report.log` shows REPORT_SAVED=...
    log_marker: "REPORT_SAVED=data/reports/device_report.txt"

  - title: Commit, Push, Verify
    goal: "Submit and verify in GitHub Classroom."
    actions: |
      Commit all changes and push. Open the Actions tab in your repo and review the autograder run.
    done_when: |
      - Actions shows green for this lab.
      - Repo contains all required scripts, raw outputs, report, and logs; health files show READY.
    log_marker: "LAB2_END"

faq:
  - q: The device type confuses me—`cisco_ios` or `cisco_xe`?
    a: Use `cisco_ios` for most IOS-XE Catalyst devices with Netmiko; verify by checking Netmiko’s supported types.
  - q: Parsing returns empty lists—what gives?
    a: Ensure the command string matches the template exactly (e.g., `show ip interface brief`, not an alias).
  - q: Where do logs and outputs go?
    a: Logs under `logs/`, raw CLI under `data/raw/`, and your final report under `data/reports/`.

submission_checklist:
  - "Logs show start/end and required markers without secrets."
  - "Raw output saved for `show ip interface brief`."
  - "Loopbacks configured and verified with saved output."
  - "Parsed data printed and included in the report."
  - "`data/reports/device_report.txt` exists and includes hostname/model/uptime."

# noop: trigger verify workflow









